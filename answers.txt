Assignment 2 - Operating Systems
Answers File

1) Explanation of code examples from Lab 5

1.1) process_creation.c

This program demonstrates the basic idea behind creating a new process using the fork() system call.
When the program calls fork(), the operating system creates a second process that starts running from the same point in the code.
If fork() returns 0, this means we are inside the child process, and it prints a message along with its own PID.
If the returned value is greater than 0, we are in the parent process, which prints its own PID.
If the return value is negative, then the fork() operation failed.

The main purpose of this example is to show that after fork(), both the parent and the child continue running the same program but each follows a different path depending on the return value.

------

1.2) file1.c and file2.c

In this example, the program is separated into two different C files to show how functions can be shared across multiple source files.
The file "file1.c" contains the actual implementation of the function hello(), which prints a simple message.
The second file, "file2.c", contains the main() function and only a declaration for hello().

When compiling them together (for example using: gcc file1.c file2.c -o output_program), the linker connects the call to hello() in file2.c with the real function definition inside file1.c.
This helps illustrate how the linker matches function declarations with their definitions across different source files.

-------

1.3) simple_program.c

This example contains a very small C program that only prints a simple line of text.
After compiling it (for example using: gcc simple_program.c -o simple_program), we use the "ldd" command to check which shared libraries the executable depends on.

The output usually shows the C standard library and the dynamic loader.
This example helps introduce the idea that when a program runs, the loader is responsible for loading both the program and the required libraries into memory.

---------

2) Shell commands used in the lab

During the lab, we also worked with a few basic shell commands to observe and manage running processes:

- "sleep 300 &"
  Starts a sleep process in the background so that the terminal remains free.

- "jobs"
  Displays the list of background jobs running in the current shell session.

- "ps aux | grep sleep"
  Shows all running system processes and filters the result to display only the sleep process.

- "kill <PID>"
  Sends a signal to a specific process, usually to terminate it.

- "kill -STOP <PID>"
  Pauses a running process without killing it.

- "kill -CONT <PID>"
  Resumes a paused process so it continues running.

These commands helped us understand how processes behave and how they can be controlled from the terminal.

-----

3) What is the job of the Linker?

The linker is a tool that runs after the compilation stage.
Its job is to take one or more object files and combine them into a single executable program.

The linker performs several important tasks:
- It connects function calls and variable references between separate object files.
- It links the program with external libraries, such as the C standard library that includes printf.
- It produces the final executable file that the operating system can load and run.

Without the linker, programs written across multiple source files would not be able to work together properly.

---

4) What is the job of the Loader?

The loader is part of the operating system and is responsible for preparing a program to run when we execute it.

When an executable is run:
- The loader reads the program from disk.
- It loads the program’s code and data into memory.
- It loads any required shared libraries into memory as well.
- It performs relocation, ensuring that all memory addresses used by the program are correct.
- Finally, it transfers control to the program’s entry point (usually the main function).

In summary, the loader takes the executable created by the linker and sets it up in memory so the CPU can start executing it.
